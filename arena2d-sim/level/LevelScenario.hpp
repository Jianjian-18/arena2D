#ifndef LEVELSCENARIO_H
#define LEVELSCENARIO_H

#include "Level.hpp"
#include "Wanderers.hpp"
#include <ros/ros.h>
#include <ros/console.h>
#include <nav_msgs/OccupancyGrid.h>
#include <nav_msgs/GetMap.h>
#include <memory>
#include <opencv2/opencv.hpp>
#include <iostream>
#define LEVEL_RANDOM_GOAL_SPAWN_AREA_BLOCK_SIZE 0.1 // maximum size of block when creating quad tree of goal spawn area

struct Scenario
{
	static std::shared_ptr<nav_msgs::OccupancyGrid> m_scenario;
	// if we dont save the node handle the logging system will not work properly, maybe a better solution can be given.
	static std::unique_ptr<ros::NodeHandle> m_nh;
	static std::shared_ptr<const nav_msgs::OccupancyGrid> getMap(const std::string &scenario_service_name)
	{
		if (!scenario_service_name.empty() && !m_scenario)
		{
			m_nh = std::unique_ptr<ros::NodeHandle>(new ros::NodeHandle("arena2d_scenario_node"));
			ros::ServiceClient map_client = m_nh->serviceClient<nav_msgs::GetMap>(scenario_service_name);
			nav_msgs::GetMap getmap;
			if (map_client.call(getmap))
			{
				ROS_INFO("Got scenario sucessfully!");
			}
			else
			{
				ROS_FATAL_STREAM("Failed to get the scenario,please make sure the the map service with the name \"" << scenario_service_name << "\" is provided!");
				exit(-1);
			}
			m_scenario = std::make_shared<nav_msgs::OccupancyGrid>(getmap.response.map);
		}
		return m_scenario;
	}
};

class LevelScenario : public Level
{
public:
	
	LevelScenario(const LevelDef & d, bool dynamic = true, bool human = true);
            

	~LevelScenario(){};

	/* reset
     */
	void reset(bool robot_position_reset) override;

	/* update
	 */
	void update() override{
		wanderers.update();
	}

	/* render spawn area
     * overriding to visualize spawn area for dynamic obstacles
     */
	void renderGoalSpawn() override;


	/* provide the agent with additional data generated by level
	 * @param data any values pushed into this vector will be passed to the agent as additional observations
	 */
	void getAgentData(std::vector<float> & data) override{
		wanderers.getWandererData(data);
	}
	/* provide the obstacle information 
	 * @param coordinate data for all robot obstacle
	 */	
	void getRobotAgentsData(std::vector<float> & data) override{
		wanderers.getRobotWandererData(data);
	}

	/* provide the obstacle information 
	 * @param coordinate data for all robot obstacle
	 */	
	void getHumanAgentsData(std::vector<float> & data) override{
		wanderers.getHumanWandererData(data);
	}

	/* get level specific reward, called after every complete simulation step (not on every step iteration)
	 * use this function to implement custom reward functions that depend on additional metrics in the level
	 * @return agent reward 
	 */
	float getReward() override;

	/* check if robot had contact with a human
 	 * @return true if contact with human and false otherwise
	 */
	bool checkHumanContact(b2Fixture * other_fixture) override{
		return wanderers.checkHumanContact(other_fixture);
	}
	
	void robotSpawnUntilValid(RectSpawn * goal_spawn = NULL) override;
	void randomGoalSpawnUntilValid(RectSpawn * goal_spawn = NULL) override;

	/**
	 * @description: check the spawn area of dynamic obstacles
	 * @return {*}
	 */		
	void dynamicObstacleSpawnUntilValid() override;

	/**
	 * @description: check the spawn area of static obstacles
	 * @return {*}
	 */	
	void staticObstacleSpawnUntilValid() override;
	/**
	 * @description: transfer waypoints from task genrator to waypoints_list
	 * @param {vector<b2Vec2>} waypoints
	 * @return {*}
	 */	
	void waypointsStore(std::vector<b2Vec2> waypoints) override;
	/**
	 * @description: clear waypoints_list
	 * @return {*}
	 */
	void waypointsClear() override;
private:
	void loadScenario();

	// the map will retain.
	void lazyclear();

	/* the ros node pointer in which the occupancy grid map was saved */
	std::shared_ptr<const nav_msgs::OccupancyGrid> _occupancygrid_ptr;

	/* if set to true, create dynamic obstacles (wanderers) in addition to static */
	bool _dynamic;
	bool _human;

	std::vector<float> _closestDistance; //current distances from robot to closest wanderers
	std::vector<float> _closestDistance_old; //last closest distances from robot to wanderers
	
	/* handles all wanderers for dynamic level */
	Wanderers wanderers;

	/* spawn area for dynamic obstacles */
	RectSpawn _dynamicSpawn;
	
	/* spawn area for static obstacles */
	RectSpawn _staticSpawn;

	// it takes too long to calculate the spawn area for dynamic obstaticles,to save the time, it will only be done once.
	bool _init_reset;
	
	/* number of bodies that shoun't be removed when lazyclear is called */
	uint32 _n_non_clear_bodies;

	cv::Mat _occupancy_map;



};

#endif
